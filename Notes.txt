Virtualna Masina za projekat - sa sajta. 

Za projekat se koristi Emulator QEMU, `qemu.org` za dokumentaciju. 

Koristimo i jos Cross Compiler koji generise masinski kod za RISCV arhitekturu. 
    - `gcc`
    - as, ld

IDE koji koristimo je iz JetBrains, `CLion`.

Od biblioteka, nas zadatak je da implementiramo Mem.lib i console.lib
Dok hw.lib bice dostupna. Kao osnovni binarni interfejs ka ovoj masini. 

Za make file imamo ikonu dole desno pored terminala unutar CLION

Prvo pre nego sto pocnemo:
- desni klik na src directory i kliknemo dole, mark directory as project sources and headers. 
- desni klik na h directory i kliknemo dole, mark directory as project sources and headers. 


In source directory create a main.c file. 

`main.c`

```cpp

#include "../lib/console.h"

void main() {
    __putc('O');
    __putc('S');
    __putc('1');
    __putc('\n');
    __putc('\n');

    while(1){
        char character = __getc();
        __putc(character+30); 
    }
}

```

Now we use make from the side to first `clean` the project. 

Than we run `all` za prevodjenje. 

Nakon sto smo ga preveli mozemo da ga pokrenemo koristi komandu `qemu`


Ali mozemo da pokrenemo `clean` pa onda `qemu` komanda ce da prevede projekat sama. 

Testiramo upis:
    `333ccc`
dobijemo:
    `QQQaaa(`


Vrsimo izvrsavanje programa koristeci terminal: make qemu

after we are done we need a character sequence to stop the program from running. 

`ctrl+a c`
`quit`


If we want to debug we use the command from the makefile: `qemu-gdb`

After we have run `qemu-gdb` we co to Edit configuration and choose,
 `Remote Debug`, We give a name to the configuration.
 We select a GDB executable. usr/bin/gdb-multiarch.
 Than for the target we add the `localhost:26000`
For the symbol file, we choose our `kernel` (no extenstion) file. 
Root directory is the root of our project. 

We run The configuration. 


Step Over in gdb terminal is: `next`
Asking for help is: `help`

`info registers` we can see all the registers. 


https://gcc.gnu.org/onlinedocs/gcc-11.2.0/gcc

// example to watch:
https://studentetfbgacrs-my.sharepoint.com/personal/sg160664d_student_etf_bg_ac_rs/_layouts/15/stream.aspx?id=%2Fpersonal%2Fsg160664d%5Fstudent%5Fetf%5Fbg%5Fac%5Frs%2FDocuments%2FETF%2FSNIMCI%20PREDAVANJA%2FSemestar%202%2Fg2%5Fs2%5FOS1%2FOS1%2Dvezbe%202022%2Fvezbe02%2Darhitektura%2Driscv%2Dnastavak%2Di%2Dadresiranje%2Dmemorije%2D1%2Fos1%2Dvezbe02%2Dzadatak03%2Emp4&referrer=StreamWebApp%2EWeb&referrerScenario=AddressBarCopied%2Eview%2E64c442e0%2Da86d%2D4fea%2D8016%2D7eaa65192d80


Vrati se na vezbe 7, uzmi implementaticiju. 


// sinhrona promena konsteksta, Vezbe 7, 2022
https://studentetfbgacrs-my.sharepoint.com/personal/sg160664d_student_etf_bg_ac_rs/_layouts/15/stream.aspx?id=%2Fpersonal%2Fsg160664d%5Fstudent%5Fetf%5Fbg%5Fac%5Frs%2FDocuments%2FETF%2FSNIMCI%20PREDAVANJA%2FSemestar%202%2Fg2%5Fs2%5FOS1%2FOS1%2Dvezbe%202022%2Fvezbe07%2Dimpl%2Dprocesa%2Di%2Dniti%2D2%2Di%2Dsinhr%2Di%2Dkomun%2Dizmedju%2Dprocesa%2D1%2Fos1%2Dvezbe07%2Dzadatak06%2Driscv%2Dcontext%2Dswitch%2D1%2Dsynchronous%2Emp4&referrer=StreamWebApp%2EWeb&referrerScenario=AddressBarCopied%2Eview%2Ee73fe996%2D4b5f%2D41b5%2D8821%2Ddb93e9515854



// asinhrona promena konteksta, supervisor mode. 
https://studentetfbgacrs-my.sharepoint.com/personal/sg160664d_student_etf_bg_ac_rs/_layouts/15/stream.aspx?id=%2Fpersonal%2Fsg160664d%5Fstudent%5Fetf%5Fbg%5Fac%5Frs%2FDocuments%2FETF%2FSNIMCI%20PREDAVANJA%2FSemestar%202%2Fg2%5Fs2%5FOS1%2FOS1%2Dvezbe%202022%2Fvezbe07%2Dimpl%2Dprocesa%2Di%2Dniti%2D2%2Di%2Dsinhr%2Di%2Dkomun%2Dizmedju%2Dprocesa%2D1%2Fos1%2Dvezbe07%2Dzadatak07%2Driscv%2Dcontext%2Dswitch%2D2%2Dinterrupt%2Emp4&referrer=StreamWebApp%2EWeb&referrerScenario=AddressBarCopied%2Eview%2Ea009da51%2D42e4%2D406d%2D9e83%2Dbaf5c6431912




# Riscv.cpp handler
```
void Riscv::handleSupervisorTrap()
{
    // Read the scause register to determine what caused the supervisor trap
    // scause contains the trap cause code that tells us whether this was an
    // interrupt or exception and what specific type it was
    uint64 scause = r_scause();
    
    // Handle system calls (environment calls from user or supervisor mode)
    if (scause == 0x0000000000000008UL || scause == 0x0000000000000009UL)
    {
        // scause = 0x08: Environment call from User mode (ecall instruction)
        // scause = 0x09: Environment call from Supervisor mode (ecall instruction)
        // These are synchronous exceptions, not interrupts (MSB = 0)
        
        // Save the exception program counter and advance it by 4 bytes
        // We add 4 to skip over the ecall instruction that caused the trap
        // so when we return, we don't re-execute the same ecall
        uint64 volatile sepc = r_sepc() + 4;
        
        // Save the current supervisor status register
        // This preserves the processor state (interrupt enable bits, privilege mode, etc.)
        uint64 volatile sstatus = r_sstatus();
        
        // Reset the time slice counter to 0
        // System calls trigger immediate context switch, so current thread
        // gets a fresh time slice when it eventually runs again
        TCB::timeSliceCounter = 0;
        
        // Perform context switch to another thread
        // This saves current thread's context and loads next thread's context
        TCB::dispatch();
        
        // Restore the status register for the newly scheduled thread
        // This sets up the processor state for the new thread
        w_sstatus(sstatus);
        
        // Set the return address for the newly scheduled thread
        // When sret is executed, execution will resume at this address
        w_sepc(sepc);
    }
    // Handle timer interrupts for preemptive scheduling
    else if (scause == 0x8000000000000001UL)
    {
        // scause = 0x8000000000000001: Supervisor software interrupt
        // This is an asynchronous interrupt (MSB = 1) typically triggered by
        // machine timer interrupt forwarded by CLINT (Core Local Interrupt Controller)
        
        // Clear the supervisor software interrupt pending bit
        // This acknowledges the interrupt and prevents it from immediately
        // triggering again when we re-enable interrupts
        mc_sip(SIP_SSIP);
        
        // Increment the time slice counter
        // Each timer interrupt represents one "tick" of execution time
        // for the currently running thread
        TCB::timeSliceCounter++;
        
        // Check if current thread has used up its allocated time slice
        if (TCB::timeSliceCounter >= TCB::running->getTimeSlice())
        {
            // Time slice expired - perform preemptive context switch
            
            // Save current program counter (no +4 needed since this is an interrupt,
            // not an exception - we want to resume exactly where we were interrupted)
            uint64 volatile sepc = r_sepc();
            
            // Save current processor status
            uint64 volatile sstatus = r_sstatus();
            
            // Reset time slice counter for round-robin scheduling
            TCB::timeSliceCounter = 0;
            
            // Switch to next thread in the ready queue
            // Current thread goes back to ready state, next thread becomes running
            TCB::dispatch();
            
            // Restore processor state for the newly scheduled thread
            w_sstatus(sstatus);
            
            // Set return address for the newly scheduled thread
            w_sepc(sepc);
        }
        // If time slice hasn't expired, simply return to the current thread
        // and let it continue executing
    }
    // Handle external interrupts (I/O devices)
    else if (scause == 0x8000000000000009UL)
    {
        // scause = 0x8000000000000009: Supervisor external interrupt
        // This is an asynchronous interrupt (MSB = 1) from external devices
        // connected through PLIC (Platform-Level Interrupt Controller)
        // Common sources: keyboard, mouse, network, disk, etc.
        
        // Handle console/keyboard input
        // This function will read from the console device and potentially
        // wake up threads waiting for input
        console_handler();
        
        // Note: No context switch occurs here unless console_handler()
        // explicitly triggers one. External interrupts are handled quickly
        // and control returns to the same thread that was interrupted.
    }
    else
    {
        // Unexpected or unhandled trap cause
        // This could be:
        // - Illegal instruction exception
        // - Load/store access fault
        // - Page fault (if virtual memory is implemented)
        // - Breakpoint exception
        // - Other hardware exceptions
        //
        // In a production OS, this would typically:
        // - Log the error
        // - Terminate the offending process
        // - Possibly panic if it's a kernel-level fault
        
        // Currently no action is taken - this could lead to undefined behavior
        // in case of unexpected traps
    }
    
    // Function returns and the trap handler wrapper will execute 'sret'
    // instruction to return from supervisor mode back to the interrupted context
}

```
